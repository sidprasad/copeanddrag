{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cope and Drag Cope and Drag (or CnD ) is a lightweight diagramming language designed for use with the Forge lightweight formal methods tool. The key idea is that CnD starts with a meaningful default visualization. Each operation added refines it. For example, you can constrain spatial layout (e.g., child nodes in a binary tree below their parents), group elements (e.g., nodes representing related components in a software architecture), or direct drawing style (e.g., color nodes in a red-black tree based on their color). The goal isn\u2019t to create pretty diagrams but to generate useful ones. Diagrams respect the model\u2019s structure and spatial relationships. If the diagram doesn\u2019t match the model, no diagram is generated, and a solver-generated error is produced. This helps identify bad instances , where the model doesn\u2019t match the author's intent, making CnD a meaningful debugging tool. \ud83d\udd0d See our upcoming paper in ECOOP 2025 . Grounded In Cognitive Science Cope and Drag is informed by findings from cognitive science about how people draw, interpret, and are confused by diagrams. Spatial Relationships Matter \u201cSpatial thinking is the foundation of abstract thought\u201d - Barbara Tversky People read meaning into position - above, below, inside. Cope and Drag's constraints allow authors to shape diagram layouts to reflect these meaningful relationships. When spatial relationships in a diagram reflect domain relationships, they serve as cognitive aids. For example, placing a parent above its children in a family tree matches conveys a model of generational relationships, while nesting elements inside containers effectively shows membership. These spatial choices aren't just aesthetic; they help convey the semantics of the underlying model more intuitively. By making these relationships explicit through layout, Cope and Drag helps create useful, domain specific visualizations. Visual Differences \ud83d\udca1 In cognitive psychology, pre-attentive processing refers to how we perceive certain visual features\u2014like color, size, and position\u2014almost instantly, before focused attention. Visual features like color, size, and position are processed by our brains almost instantly. Cope and Drag uses these features strategically to make diagrams easier to understand at a glance. Directives allow diagrammers to control how elements are displayed (color, shapes, or size), resulting in diagrams that focus the audience on what matters most. Next Steps Getting Started : Install the tool, explore how it interfaces with Forge. Examples : Play with some pre-built example diagrams.","title":"Home"},{"location":"#cope-and-drag","text":"Cope and Drag (or CnD ) is a lightweight diagramming language designed for use with the Forge lightweight formal methods tool. The key idea is that CnD starts with a meaningful default visualization. Each operation added refines it. For example, you can constrain spatial layout (e.g., child nodes in a binary tree below their parents), group elements (e.g., nodes representing related components in a software architecture), or direct drawing style (e.g., color nodes in a red-black tree based on their color). The goal isn\u2019t to create pretty diagrams but to generate useful ones. Diagrams respect the model\u2019s structure and spatial relationships. If the diagram doesn\u2019t match the model, no diagram is generated, and a solver-generated error is produced. This helps identify bad instances , where the model doesn\u2019t match the author's intent, making CnD a meaningful debugging tool. \ud83d\udd0d See our upcoming paper in ECOOP 2025 .","title":"Cope and Drag"},{"location":"#grounded-in-cognitive-science","text":"Cope and Drag is informed by findings from cognitive science about how people draw, interpret, and are confused by diagrams.","title":"Grounded In Cognitive Science"},{"location":"#spatial-relationships-matter","text":"\u201cSpatial thinking is the foundation of abstract thought\u201d - Barbara Tversky People read meaning into position - above, below, inside. Cope and Drag's constraints allow authors to shape diagram layouts to reflect these meaningful relationships. When spatial relationships in a diagram reflect domain relationships, they serve as cognitive aids. For example, placing a parent above its children in a family tree matches conveys a model of generational relationships, while nesting elements inside containers effectively shows membership. These spatial choices aren't just aesthetic; they help convey the semantics of the underlying model more intuitively. By making these relationships explicit through layout, Cope and Drag helps create useful, domain specific visualizations.","title":"Spatial Relationships Matter"},{"location":"#visual-differences","text":"\ud83d\udca1 In cognitive psychology, pre-attentive processing refers to how we perceive certain visual features\u2014like color, size, and position\u2014almost instantly, before focused attention. Visual features like color, size, and position are processed by our brains almost instantly. Cope and Drag uses these features strategically to make diagrams easier to understand at a glance. Directives allow diagrammers to control how elements are displayed (color, shapes, or size), resulting in diagrams that focus the audience on what matters most.","title":"Visual Differences"},{"location":"#next-steps","text":"Getting Started : Install the tool, explore how it interfaces with Forge. Examples : Play with some pre-built example diagrams.","title":"Next Steps"},{"location":"constraints/","text":"Constraints Constraints define spatial relationships between elements in the diagram. Each constraint consists of a type and associated parameters . Cyclic Constraints Cyclic constraints arrange related elements in a circular layout. To be more precise, related elements are laid out roughly as a regular shape of n sides, where there are n related elements in the selector. The layout below is used in the Ring Lights example to arrange a ring of lights along the boundary of a pentagon. 1 2 3 4 5 6 constraints : - cyclic : selector : left direction : clockwise directives : - flag : hideDisconnectedBuiltIns Parameters selector : A Forge expression that determines which elements upon which the constraint acts. This expression must return a set of elements of arity >= 2, and the first and last of each tuple will be used. If multiple closed relations are returned, multiple cycles are generated. For example, a selector evaluating to {(A, B), (B, C), (C,A), (E,F), (F,E)} will construct two independent shapes -- one relating A, B, C and another relating E,F . direction : [Optional] Direction in which elements will be laid out. One of clockwise or counterclockwise . Defaults to clockwise Orientation Constraints Specify the relative positioning of elements in a graph. The layout below is used in the binary tree example shows how to ensure that a node's right children are laid out below it and to its right, and that its left children are laid out below it and to its left. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 constraints : - orientation : selector : right directions : - right - below - orientation : selector : left directions : - left - below directives : - attribute : field : key - flag : hideDisconnectedBuiltIns Parameters selector : A Forge expression that determines which elements upon which the constraint acts. This expression must return a set of elements of arity >= 2, and the first and last of each tuple will be used. directions : Directions in which elements will be laid out. List of directions, which can be left , right , above , below , directlyAbove , directlyBelow , directlyLeft , directlyRight . Grouping Constraints Group elements together based on either a selector OR a field . Groups cannot intersect unless one is subsumed by another. Grouping by Field Grouping by field removes multiple edges between the group source(s) and target(s), and replaces them with the lowest number of arrows between group and element. The layout below shows the pertinent part of the Fruit in Baskets example, which uses the 0th element of the fruit relation as a key and adds elements in the 1st part of the relation to the associated group. 1 2 3 4 - group : field : fruit groupOn : 0 addToGroup : 1 Parameters field : Name of the field in the source specification upon which the constraint acts. groupOn : The 0 indexed element of the field that is used to group elements. addToGroup : The 0 indexed element of the field which should be added to the group. Grouping by Selector Grouping by selector affords a more flexible way to create groups. This operation, however, does not have required context to collapse multiple graph edges. As a result, it does not remove any edges from the graph . The layout below shows the pertinent part of the Fruit in Baskets example, which uses a n-ary selector to group rotten fruit that are in the same basket together. 1 2 3 - group : selector : '{b : Basket, a : Fruit | (a in b.fruit) and a.status = Rotten }' name : rottenFruit Parameters selector : A Forge expression that determines which elements upon which the constraint acts. If the selector evaluates to a set of singletons, all singletons are added to the group. If the selector evaluates to a set of tuples, the first element of the tuple is used as as a key upon which to group, while the last element of the tuple is added to the group associated with that key. For example, name : Name of the group to be displayed. When Constraints Cannot Be Satisfied All CnD constraints are hard constraints , and thus must be satisfied for a diagram to be produced. Constraints might not be satisfied for one of two reasons: A single CnD constraint definition could be inherently unsatisfiable. For example, a constraint on the next field that requires the same field to be laid out both leftwards and rightwards: 1 2 3 - orientation : selector : next directions : [ right , left ] This represents a bug in the CnD spec, and can be identified statically. In this case, CnD produces an error message in terms of the constraints that could not be satisfied. Some constraints may be individually satisfiable, but become contradictory when laying out a specific instance. This is akin to a dynamic error, as it depends on the structure of the instance being visualized. In both these cases, CnD does not produce a diagram . Instead, it provides an error message explaining that the constraints could not be met.","title":"Constraints"},{"location":"constraints/#constraints","text":"Constraints define spatial relationships between elements in the diagram. Each constraint consists of a type and associated parameters .","title":"Constraints"},{"location":"constraints/#cyclic-constraints","text":"Cyclic constraints arrange related elements in a circular layout. To be more precise, related elements are laid out roughly as a regular shape of n sides, where there are n related elements in the selector. The layout below is used in the Ring Lights example to arrange a ring of lights along the boundary of a pentagon. 1 2 3 4 5 6 constraints : - cyclic : selector : left direction : clockwise directives : - flag : hideDisconnectedBuiltIns","title":"Cyclic Constraints"},{"location":"constraints/#parameters","text":"selector : A Forge expression that determines which elements upon which the constraint acts. This expression must return a set of elements of arity >= 2, and the first and last of each tuple will be used. If multiple closed relations are returned, multiple cycles are generated. For example, a selector evaluating to {(A, B), (B, C), (C,A), (E,F), (F,E)} will construct two independent shapes -- one relating A, B, C and another relating E,F . direction : [Optional] Direction in which elements will be laid out. One of clockwise or counterclockwise . Defaults to clockwise","title":"Parameters"},{"location":"constraints/#orientation-constraints","text":"Specify the relative positioning of elements in a graph. The layout below is used in the binary tree example shows how to ensure that a node's right children are laid out below it and to its right, and that its left children are laid out below it and to its left. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 constraints : - orientation : selector : right directions : - right - below - orientation : selector : left directions : - left - below directives : - attribute : field : key - flag : hideDisconnectedBuiltIns","title":"Orientation Constraints"},{"location":"constraints/#parameters_1","text":"selector : A Forge expression that determines which elements upon which the constraint acts. This expression must return a set of elements of arity >= 2, and the first and last of each tuple will be used. directions : Directions in which elements will be laid out. List of directions, which can be left , right , above , below , directlyAbove , directlyBelow , directlyLeft , directlyRight .","title":"Parameters"},{"location":"constraints/#grouping-constraints","text":"Group elements together based on either a selector OR a field . Groups cannot intersect unless one is subsumed by another.","title":"Grouping Constraints"},{"location":"constraints/#grouping-by-field","text":"Grouping by field removes multiple edges between the group source(s) and target(s), and replaces them with the lowest number of arrows between group and element. The layout below shows the pertinent part of the Fruit in Baskets example, which uses the 0th element of the fruit relation as a key and adds elements in the 1st part of the relation to the associated group. 1 2 3 4 - group : field : fruit groupOn : 0 addToGroup : 1","title":"Grouping by Field"},{"location":"constraints/#parameters_2","text":"field : Name of the field in the source specification upon which the constraint acts. groupOn : The 0 indexed element of the field that is used to group elements. addToGroup : The 0 indexed element of the field which should be added to the group.","title":"Parameters"},{"location":"constraints/#grouping-by-selector","text":"Grouping by selector affords a more flexible way to create groups. This operation, however, does not have required context to collapse multiple graph edges. As a result, it does not remove any edges from the graph . The layout below shows the pertinent part of the Fruit in Baskets example, which uses a n-ary selector to group rotten fruit that are in the same basket together. 1 2 3 - group : selector : '{b : Basket, a : Fruit | (a in b.fruit) and a.status = Rotten }' name : rottenFruit","title":"Grouping by Selector"},{"location":"constraints/#parameters_3","text":"selector : A Forge expression that determines which elements upon which the constraint acts. If the selector evaluates to a set of singletons, all singletons are added to the group. If the selector evaluates to a set of tuples, the first element of the tuple is used as as a key upon which to group, while the last element of the tuple is added to the group associated with that key. For example, name : Name of the group to be displayed.","title":"Parameters"},{"location":"constraints/#when-constraints-cannot-be-satisfied","text":"All CnD constraints are hard constraints , and thus must be satisfied for a diagram to be produced. Constraints might not be satisfied for one of two reasons: A single CnD constraint definition could be inherently unsatisfiable. For example, a constraint on the next field that requires the same field to be laid out both leftwards and rightwards: 1 2 3 - orientation : selector : next directions : [ right , left ] This represents a bug in the CnD spec, and can be identified statically. In this case, CnD produces an error message in terms of the constraints that could not be satisfied. Some constraints may be individually satisfiable, but become contradictory when laying out a specific instance. This is akin to a dynamic error, as it depends on the structure of the instance being visualized. In both these cases, CnD does not produce a diagram . Instead, it provides an error message explaining that the constraints could not be met.","title":"When Constraints Cannot Be Satisfied"},{"location":"directives/","text":"Directives Directives control the visual representation of elements, including icons, colors, attributes, and visibility. Attribute Directives These replace graph edges representing a relation with attribute fields within the source node of the edge. 1 2 directives: - attribute: {field: id} Parameters field : Name of the field in the source specification upon which the directive acts. Field Hiding Directives These remove graph edges representing a relation from the graph. This is similar to an attribute directive, but without adding data to an edge's source node. 1 2 3 directives: - hideField: field: id Parameters field : Name of the field in the source specification upon which the directive acts. Size Directives Assign a size to all atoms that meet a certain selector. 1 2 3 4 5 directives : - size : selector : \"Person\" height : 20 width : 20 Parameters selector : A Forge expression that determines which elements upon which the directive acts. This expression must return a set of singletons. height : Height with which the node should be displayed. width : Width with which the node should be displayed. Pictorial Directives Assign an icon to all atoms of a certain sig. 1 2 3 4 directives : - icon : selector : Person path : /path/to/person.png Parameters selector : A Forge expression that determines which elements upon which the directive acts. This expression must return a set of singletons. path : Path to the icon image ( png and jpg supported). This path must be a publicly accessible URI. showLabels : [Optional, default false ] Should atom labels (e.g., atom name, attributes) be shown in addition to icons. If true , the icon is made smaller to prevent overlap with label text. Built In Icons Cope and Drag also includes a selection of built in icons for ease of use. Color Directives Allow specific hex-colors (or simple color names) to be associated with selected atoms. 1 2 3 4 directives: - color: selector: \"Apple\" value: \"red\" Parameters selector : A Forge expression that determines which elements upon which the constraint acts. This expression must return a set of singletons. value : Hex (or simple english) description of the color to be applied. Projection These allow projections over atoms of a certain type. 1 2 directives: - projection: {sig: Ord} Parameters sig : Sig name in the source specification. Visibility Flags Controls which elements are hidden. 1 2 directives : - flag : hideDisconnectedBuiltIns Current flags are: - hideDisconnected : If true, hide all atoms in the graph that are not referenced by a relation. - hideDisconnectedBuiltIns : If true, hide all atoms of built-in type (ex. Int ) that are not referenced by a relation. Inferred Edge The inferredEdge directive introduces visually distinct edges that represent inferred relationships \u2014 connections the diagrammer wants the viewer to see to better understand the model. These edges are not part of the model itself but help the viewer mentally hold and interpret higher-level connections. 1 2 3 4 directives : - inferredEdge : selector : '{n1 : Node, i : Int, n2 : Node | n1->n2->i in edges }' name : weight Parameters selector : A Forge expression that determines which elements upon which the constraint acts. This expression must return a set of elements of arity >= 2, and the first and last of each tuple will be used. name : The label to be given to this edge. Any ''middle'' tuple elements in the selector (i.e. elements that are not first or last in the tuple) are appended to this name to better identify edges.","title":"Directives"},{"location":"directives/#directives","text":"Directives control the visual representation of elements, including icons, colors, attributes, and visibility.","title":"Directives"},{"location":"directives/#attribute-directives","text":"These replace graph edges representing a relation with attribute fields within the source node of the edge. 1 2 directives: - attribute: {field: id}","title":"Attribute Directives"},{"location":"directives/#parameters","text":"field : Name of the field in the source specification upon which the directive acts.","title":"Parameters"},{"location":"directives/#field-hiding-directives","text":"These remove graph edges representing a relation from the graph. This is similar to an attribute directive, but without adding data to an edge's source node. 1 2 3 directives: - hideField: field: id","title":"Field Hiding Directives"},{"location":"directives/#parameters_1","text":"field : Name of the field in the source specification upon which the directive acts.","title":"Parameters"},{"location":"directives/#size-directives","text":"Assign a size to all atoms that meet a certain selector. 1 2 3 4 5 directives : - size : selector : \"Person\" height : 20 width : 20","title":"Size Directives"},{"location":"directives/#parameters_2","text":"selector : A Forge expression that determines which elements upon which the directive acts. This expression must return a set of singletons. height : Height with which the node should be displayed. width : Width with which the node should be displayed.","title":"Parameters"},{"location":"directives/#pictorial-directives","text":"Assign an icon to all atoms of a certain sig. 1 2 3 4 directives : - icon : selector : Person path : /path/to/person.png","title":"Pictorial Directives"},{"location":"directives/#parameters_3","text":"selector : A Forge expression that determines which elements upon which the directive acts. This expression must return a set of singletons. path : Path to the icon image ( png and jpg supported). This path must be a publicly accessible URI. showLabels : [Optional, default false ] Should atom labels (e.g., atom name, attributes) be shown in addition to icons. If true , the icon is made smaller to prevent overlap with label text.","title":"Parameters"},{"location":"directives/#built-in-icons","text":"Cope and Drag also includes a selection of built in icons for ease of use.","title":"Built In Icons"},{"location":"directives/#color-directives","text":"Allow specific hex-colors (or simple color names) to be associated with selected atoms. 1 2 3 4 directives: - color: selector: \"Apple\" value: \"red\"","title":"Color Directives"},{"location":"directives/#parameters_4","text":"selector : A Forge expression that determines which elements upon which the constraint acts. This expression must return a set of singletons. value : Hex (or simple english) description of the color to be applied.","title":"Parameters"},{"location":"directives/#projection","text":"These allow projections over atoms of a certain type. 1 2 directives: - projection: {sig: Ord}","title":"Projection"},{"location":"directives/#parameters_5","text":"sig : Sig name in the source specification.","title":"Parameters"},{"location":"directives/#visibility-flags","text":"Controls which elements are hidden. 1 2 directives : - flag : hideDisconnectedBuiltIns Current flags are: - hideDisconnected : If true, hide all atoms in the graph that are not referenced by a relation. - hideDisconnectedBuiltIns : If true, hide all atoms of built-in type (ex. Int ) that are not referenced by a relation.","title":"Visibility Flags"},{"location":"directives/#inferred-edge","text":"The inferredEdge directive introduces visually distinct edges that represent inferred relationships \u2014 connections the diagrammer wants the viewer to see to better understand the model. These edges are not part of the model itself but help the viewer mentally hold and interpret higher-level connections. 1 2 3 4 directives : - inferredEdge : selector : '{n1 : Node, i : Int, n2 : Node | n1->n2->i in edges }' name : weight","title":"Inferred Edge"},{"location":"directives/#parameters_6","text":"selector : A Forge expression that determines which elements upon which the constraint acts. This expression must return a set of elements of arity >= 2, and the first and last of each tuple will be used. name : The label to be given to this edge. Any ''middle'' tuple elements in the selector (i.e. elements that are not first or last in the tuple) are appended to this name to better identify edges.","title":"Parameters"},{"location":"faq/","text":"FAQ This page documents common issues users have faced when using Cope and Drag, as well as work-arounds. We encourage you to file issues here if you see something not addressed below. Why Cope and Drag? The name comes from sand casting: the cope is the top half of a mold, the drag the bottom\u2014both must align to create something solid. So too in modeling: logic and layout must support each other. How can I use local images as icons? Cope and Drag icons directives currently only support images hosted on publicly available URIs. If you want a specific image on your local filesystem to be used in an icon directive: Generate a base64 encoding of this image ( we've found this website useful ). Include the base 64 URI in your icon path as below: 1 2 3 - icon: path: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAO8AAAEACAMAAABsy9Fo.... selector: someselector Cope and Drag also includes a selection of built in icons for ease of use. How can I integrate Cope and Drag with my own workflow? Cope and Drag API endpoints are documented via the Open API convention, and can be found at the /openapi endpoint of your running Cope and Drag instance.","title":"FAQ"},{"location":"faq/#faq","text":"This page documents common issues users have faced when using Cope and Drag, as well as work-arounds. We encourage you to file issues here if you see something not addressed below.","title":"FAQ"},{"location":"faq/#why-cope-and-drag","text":"The name comes from sand casting: the cope is the top half of a mold, the drag the bottom\u2014both must align to create something solid. So too in modeling: logic and layout must support each other.","title":"Why Cope and Drag?"},{"location":"faq/#how-can-i-use-local-images-as-icons","text":"Cope and Drag icons directives currently only support images hosted on publicly available URIs. If you want a specific image on your local filesystem to be used in an icon directive: Generate a base64 encoding of this image ( we've found this website useful ). Include the base 64 URI in your icon path as below: 1 2 3 - icon: path: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAO8AAAEACAMAAABsy9Fo.... selector: someselector Cope and Drag also includes a selection of built in icons for ease of use.","title":"How can I use local images as icons?"},{"location":"faq/#how-can-i-integrate-cope-and-drag-with-my-own-workflow","text":"Cope and Drag API endpoints are documented via the Open API convention, and can be found at the /openapi endpoint of your running Cope and Drag instance.","title":"How can I integrate Cope and Drag with my own workflow?"},{"location":"underthehood/","text":"Under the Hood \ud83d\udd27 This page is still under construction \ud83d\udd27 CnD uses a combination of tools to compute and render visual layouts: Cassowary checks whether the given set of constraints allows for a valid layout. If a solution exists, Cassowary will find it. WebCola computes the final layout based on the satisfied constraints, optimizing the spatial arrangement of elements. D3 helps implement visual directives such as color, icons, styling, etc.","title":"Under the Hood"},{"location":"underthehood/#under-the-hood","text":"\ud83d\udd27 This page is still under construction \ud83d\udd27 CnD uses a combination of tools to compute and render visual layouts: Cassowary checks whether the given set of constraints allows for a valid layout. If a solution exists, Cassowary will find it. WebCola computes the final layout based on the satisfied constraints, optimizing the spatial arrangement of elements. D3 helps implement visual directives such as color, icons, styling, etc.","title":"Under the Hood"},{"location":"bundledicons/","text":"Bundled Icons Cope and Drag includes the following built-in icons for ease of use. To use any of these icons, just use the icon path below in your CnD spec. 1 2 3 4 directives : - icon : selector : Apple path : /img/apple.png Icon Icon Path /img/apple.png /img/eye.png /img/fork.png /img/nose.png /img/wolf.png /img/banana.png /img/eyebrow.png /img/goat.png /img/pear.png /img/mouth.png /img/person.png /img/fish.png","title":"Bundled Icons"},{"location":"bundledicons/#bundled-icons","text":"Cope and Drag includes the following built-in icons for ease of use. To use any of these icons, just use the icon path below in your CnD spec. 1 2 3 4 directives : - icon : selector : Apple path : /img/apple.png Icon Icon Path /img/apple.png /img/eye.png /img/fork.png /img/nose.png /img/wolf.png /img/banana.png /img/eyebrow.png /img/goat.png /img/pear.png /img/mouth.png /img/person.png /img/fish.png","title":"Bundled Icons"},{"location":"examples/","text":"Examples These example diagrams demonstrate key features of CnD . You can interact with each example directly in your browser using a client-side viewer (note: the Cope and Drag specification cannot be edited in this mode), or download the full example as a .zip file for use with Cope and Drag at the /import endpoint. Binary Tree Uses orientation constraints to ensure that a binary tree's children are appropriately laid out. View Interactive Diagram Download Example Fruit in Baskets Uses grouping constraints to group a set of fruit by the baskets they are in, as well as group all rotten fruit in a basket together. Also uses icons to identify each fruit type. View Interactive Diagram Download Example Ring Lights Uses cyclic constraints to arrange a ring of lights along the boundary of a regular shape. View Interactive Diagram Download Example Tic Tac Toe Uses orientation constraints to arrange a tic tac toe board. View Interactive Diagram Download Example","title":"Examples"},{"location":"examples/#examples","text":"These example diagrams demonstrate key features of CnD . You can interact with each example directly in your browser using a client-side viewer (note: the Cope and Drag specification cannot be edited in this mode), or download the full example as a .zip file for use with Cope and Drag at the /import endpoint.","title":"Examples"},{"location":"getting-started/","text":"Getting Started CnD is integrated into the Forge pedagogic model finder, which is heavily inspired by the Alloy tool and language. This guide assumes you have a basic understanding of Forge or Alloy. If you need an introduction to Forge, check out the Forge documentation . Installing CnD You can install CnD in one of the following ways: A stable, but less often updated version of CnD is packaged with the Forge VS Code Extension . This automatically launches CnD at localhost:3000 . NPM : CnD is available as an NPM package . You can install and launch CnD as follows: 1 2 npm i cope-and-drag # Install copeanddrag --port 3000 # Port is optional, defaults to 3000 From a specific GitHub release : Download CnD from GitHub releases and run node index.js Running CnD with Forge These instructions assume that you have an actively running CnD server on port 3000 . If you are using the Forge VS Code Extension, you will not have to manually launch CnD. Run a Forge specification that includes a run statement (an example is available here ). This will open up Sterling, the default Forge visualizer, in a browser window. Run your command, and then, once Sterling displays a graph, click the Layout drawer. Select Load Layout to load the graph in Cope and Drag. If you already have a Cope and Drag specification, you can paste it in here before clicking load layout. Click the highlighted button to open the Sterling Layout Drawer CnD will now open in a different tab. You can now start adding constraints that define spatial relationships between elements and directives that control visual styling and representation. These can be expressed both via YAML and a structured, no-code interface. If you are just starting with CnD , we recommend beginning with the No Code interface. YAML Interface for Authoring Diagrams No Code Interface for Authoring Diagrams Once you have clicked 'Apply Layout', CnD will apply your specification to generate a new diagram. Running CnD with Alloy For the moment, the best way to use CnD with Alloy is by pasting the instance XML that Alloy produces into CnD directly. To do this: From within Alloy's instance visualizer, select the File -> Export To -> XML menu option. Exporting an Alloy instance as XML Open the XML file in a text editor and copy its entire contents to clipboard. Click the Edit Datum button in the CnD Layout pane, then paste the XML into the edit box. Click Apply Layout . The instance will be displayed and CnD constraints and directives will be available for visualization. This includes selectors that use the (substantial) set of operators shared by both Forge and Alloy: join, set comprehension, cardinality, and so on. Next Steps Read about Constraints Learn about Directives","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"CnD is integrated into the Forge pedagogic model finder, which is heavily inspired by the Alloy tool and language. This guide assumes you have a basic understanding of Forge or Alloy. If you need an introduction to Forge, check out the Forge documentation .","title":"Getting Started"},{"location":"getting-started/#installing-cnd","text":"You can install CnD in one of the following ways: A stable, but less often updated version of CnD is packaged with the Forge VS Code Extension . This automatically launches CnD at localhost:3000 . NPM : CnD is available as an NPM package . You can install and launch CnD as follows: 1 2 npm i cope-and-drag # Install copeanddrag --port 3000 # Port is optional, defaults to 3000 From a specific GitHub release : Download CnD from GitHub releases and run node index.js","title":"Installing CnD"},{"location":"getting-started/#running-cnd-with-forge","text":"These instructions assume that you have an actively running CnD server on port 3000 . If you are using the Forge VS Code Extension, you will not have to manually launch CnD. Run a Forge specification that includes a run statement (an example is available here ). This will open up Sterling, the default Forge visualizer, in a browser window. Run your command, and then, once Sterling displays a graph, click the Layout drawer. Select Load Layout to load the graph in Cope and Drag. If you already have a Cope and Drag specification, you can paste it in here before clicking load layout. Click the highlighted button to open the Sterling Layout Drawer CnD will now open in a different tab. You can now start adding constraints that define spatial relationships between elements and directives that control visual styling and representation. These can be expressed both via YAML and a structured, no-code interface. If you are just starting with CnD , we recommend beginning with the No Code interface. YAML Interface for Authoring Diagrams No Code Interface for Authoring Diagrams Once you have clicked 'Apply Layout', CnD will apply your specification to generate a new diagram.","title":"Running CnD with Forge"},{"location":"getting-started/#running-cnd-with-alloy","text":"For the moment, the best way to use CnD with Alloy is by pasting the instance XML that Alloy produces into CnD directly. To do this: From within Alloy's instance visualizer, select the File -> Export To -> XML menu option. Exporting an Alloy instance as XML Open the XML file in a text editor and copy its entire contents to clipboard. Click the Edit Datum button in the CnD Layout pane, then paste the XML into the edit box. Click Apply Layout . The instance will be displayed and CnD constraints and directives will be available for visualization. This includes selectors that use the (substantial) set of operators shared by both Forge and Alloy: join, set comprehension, cardinality, and so on.","title":"Running CnD with Alloy"},{"location":"getting-started/#next-steps","text":"Read about Constraints Learn about Directives","title":"Next Steps"}]}