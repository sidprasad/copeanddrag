
<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Alloy Instance Diagram</title>
    <style>


        #svg-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Adjust as needed */
        }
        .svg-border {
            border: 2px solid black;
        }


        .node {
            /* stroke: black; */
            /*fill: white;*/
            stroke-width: 1.5px;
            cursor: move;
        }

        .group {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: move;
            opacity: 0.7;
        }

        .link {
            stroke: black;
            fill: none;
            stroke-width: 1px;
            stroke-opacity: 1;
            marker-end: url(#end-arrow);
        }

        .linkarrow {
            stroke: darkslategrey;
            fill: darkslategrey;
            stroke-width: 0px;
            stroke-opacity: 0.7;
            marker-end: url(#end-arrow);
        }

        .linkoutline {
            stroke: white;
            stroke-width: 4px;
            fill: none;
        }

        .label {
            fill: black;
            font-family: system-ui;
            font-size: 10px;
            text-anchor: middle;
            cursor: move;
        }

        .link-label {

            fill: black;
            font-family: Verdana;
            font-size: 10px;
            text-anchor: middle;
            cursor: move;
        }

        .groupLabel {
            fill: black;
            font-family: Verdana;
            font-size: 10px;
            text-anchor: middle;
            cursor: move;
        }
    </style>

    <script src="https://marvl.infotech.monash.edu/webcola/extern/graphlib-dot.min.js"></script>
    <!-- Minified version -->
    <!-- <script src="http://marvl.infotech.monash.edu/webcola/cola.min.js"></script> -->
    <!-- Full version -->
    <script src="https://marvl.infotech.monash.edu/webcola/cola.min.js"></script>

    <!-- Include d3 here -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
</head>

<body>
    <div class="container">
        <h1>Diagram Instance</h1>

        <hr>
        <div class="container-fluid" id="svg-container" >
            <svg id="svg" width="800" height="800" class="svg-border" >
                <defs>
                    <marker id="end-arrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" />
                    </marker>
                </defs>
                <g class="zoomable">
                    <!-- Your graph elements go here -->
                </g>
            </svg>
            <script>

                // Function to generate a random offset along the path
                function getRandomOffsetAlongPath() {
                    return (Math.random() - 0.5) * 20; // Random value between -10 and 10
                }

                // Create a zoom behavior
                var zoom = d3.zoom()
                    .scaleExtent([0.5, 5]) // Set the zoom scale limits
                    .on("zoom", zoomed);

                function zoomed() {
                    d3.select(".zoomable").attr("transform", d3.event.transform);
                }

                window.addEventListener('load', function () {


                    const dy_for_linespacing = 5; // Adjust for spacing between lines

                    var color = d3.scaleOrdinal(d3.schemeCategory20);
                    var width = 800, height = 800;

                    var svg_top = d3.select("#svg").call(zoom);


                    var svg = d3.select(".zoomable");


                    const initialUnconstrainedIterations = 10; //unconstrained initial layout iterations
                    const initialUserConstraintIterations = 100; // initial layout iterations with user-specified constraints
                    const initialAllConstraintsIterations = 50; // initial layout iterations with all constraints including non-overlap
                    const gridSnapIterations = 5; // iterations of "grid snap", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and heigh


                    var colaLayout = cola.d3adaptor(d3)
                        //.convergenceThreshold(0.1) // TODO: What should we do here?
                        .avoidOverlaps(true)
                        .handleDisconnected(true)
                        .size([width, height]);

                    var nodes = [{"id":"Chicken0","color":"#4C57C7","attributes":{},"width":70,"height":45,"x":400,"y":400},{"id":"Cheese0","color":"#21AD69","attributes":{},"width":70,"height":45,"x":400,"y":400},{"id":"Egg0","color":"#6E6683","attributes":{},"width":70,"height":45,"x":400,"y":400},{"id":"Ham0","color":"#EBDAF8","attributes":{},"width":70,"height":45,"x":400,"y":400},{"id":"Liliput0","color":"#5390AC","attributes":{"eating":["Cheese0"]},"width":70,"height":45,"x":400,"y":400},{"id":"Liliput1","color":"#5390AC","attributes":{"eating":["Cheese0"]},"width":70,"height":45,"x":400,"y":400},{"id":"Liliput2","color":"#5390AC","attributes":{"eating":["Chicken0"]},"width":70,"height":45,"x":400,"y":400},{"id":"Brobdingnag0","color":"#4FDDF7","attributes":{"eating":["Cheese0"]},"width":70,"height":45,"x":400,"y":400},{"id":"Brobdingnag1","color":"#4FDDF7","attributes":{"eating":["Ham0"]},"width":70,"height":45,"x":400,"y":400},{"id":"Brobdingnag2","color":"#4FDDF7","attributes":{"eating":["Egg0"]},"width":70,"height":45,"x":400,"y":400},{"id":"Table0","color":"#FE91A8","attributes":{},"width":70,"height":45,"x":400,"y":400},{"id":"Table1","color":"#FE91A8","attributes":{},"width":70,"height":45,"x":400,"y":400},{"id":"Table2","color":"#FE91A8","attributes":{},"width":70,"height":45,"x":400,"y":400},{"id":"Blefuscu0","color":"#78A5D8","attributes":{"eating":["Cheese0"]},"width":70,"height":45,"x":400,"y":400},{"id":"Blefuscu1","color":"#78A5D8","attributes":{"eating":["Ham0"]},"width":70,"height":45,"x":400,"y":400},{"id":"Blefuscu2","color":"#78A5D8","attributes":{"eating":["Ham0"]},"width":70,"height":45,"x":400,"y":400},{"id":"Blefuscu3","color":"#78A5D8","attributes":{"eating":["Egg0"]},"width":70,"height":45,"x":400,"y":400},{"id":"_right_0","color":"transparent","attributes":{},"width":70,"height":45,"x":400,"y":400},{"id":"_right_1","color":"transparent","attributes":{},"width":70,"height":45,"x":400,"y":400},{"id":"_right_2","color":"transparent","attributes":{},"width":70,"height":45,"x":400,"y":400}];
                    var edges = [{"source":4,"target":5,"relName":"right","id":"Person<:right:Liliput0->Liliput1","label":"right"},{"source":5,"target":4,"relName":"right","id":"Person<:right:Liliput1->Liliput0","label":"right"},{"source":6,"target":7,"relName":"right","id":"Person<:right:Liliput2->Brobdingnag0","label":"right"},{"source":13,"target":15,"relName":"right","id":"Person<:right:Blefuscu0->Blefuscu2","label":"right"},{"source":14,"target":9,"relName":"right","id":"Person<:right:Blefuscu1->Brobdingnag2","label":"right"},{"source":15,"target":16,"relName":"right","id":"Person<:right:Blefuscu2->Blefuscu3","label":"right"},{"source":16,"target":6,"relName":"right","id":"Person<:right:Blefuscu3->Liliput2","label":"right"},{"source":7,"target":8,"relName":"right","id":"Person<:right:Brobdingnag0->Brobdingnag1","label":"right"},{"source":8,"target":13,"relName":"right","id":"Person<:right:Brobdingnag1->Blefuscu0","label":"right"},{"source":9,"target":14,"relName":"right","id":"Person<:right:Brobdingnag2->Blefuscu1","label":"right"},{"source":4,"target":12,"relName":"table","id":"Person<:table:Liliput0->Table2","label":"table"},{"source":6,"target":11,"relName":"table","id":"Person<:table:Liliput2->Table1","label":"table"},{"source":14,"target":10,"relName":"table","id":"Person<:table:Blefuscu1->Table0","label":"table"}];
                    var constraints = [{"axis":"x","left":17,"right":5,"gap":100},{"axis":"y","left":5,"right":17,"gap":0},{"axis":"x","left":4,"right":17,"gap":100},{"axis":"y","left":17,"right":4,"gap":1.2246467991473532e-14},{"axis":"x","left":18,"right":7,"gap":100},{"axis":"y","left":7,"right":18,"gap":0},{"axis":"x","left":18,"right":8,"gap":50.000000000000014},{"axis":"y","left":18,"right":8,"gap":86.60254037844386},{"axis":"x","left":13,"right":18,"gap":49.99999999999998},{"axis":"y","left":18,"right":13,"gap":86.60254037844388},{"axis":"x","left":15,"right":18,"gap":100},{"axis":"y","left":18,"right":15,"gap":1.2246467991473532e-14},{"axis":"x","left":16,"right":18,"gap":50.00000000000004},{"axis":"y","left":16,"right":18,"gap":86.60254037844385},{"axis":"x","left":18,"right":6,"gap":49.999999999999936},{"axis":"y","left":6,"right":18,"gap":86.6025403784439},{"axis":"x","left":19,"right":9,"gap":100},{"axis":"y","left":9,"right":19,"gap":0},{"axis":"x","left":14,"right":19,"gap":100},{"axis":"y","left":19,"right":14,"gap":1.2246467991473532e-14}];
                    var groups = [{"leaves":[4,5,17],"padding":20,"name":"Table2:table","groups":[],"keyNode":12,"id":"Table2:table"},{"leaves":[6,13,15,16,7,8,18],"padding":20,"name":"Table1:table","groups":[],"keyNode":11,"id":"Table1:table"},{"leaves":[14,9,19],"padding":20,"name":"Table0:table","groups":[],"keyNode":10,"id":"Table0:table"}];


                    const LINK_DISTANCE = Math.min(width, height) / Math.sqrt(nodes.length);
                    console.log("Link distance: " + LINK_DISTANCE);
                    nodes.forEach(function (node) {
                        node.name = node.id;
                    });


                    colaLayout
                        .nodes(nodes)
                        .links(edges)
                        .constraints(constraints)
                        .groups(groups)
                        .jaccardLinkLengths(LINK_DISTANCE, 2);


                    const margin = 10;

                    var lineFunction = d3.line()
                        .x(function (d) { return d.x; })
                        .y(function (d) { return d.y; })
                        .curve(d3.curveBasis);

                    var routeEdges = function () {
                        colaLayout.prepareEdgeRouting(margin / 3);
                        console.log("Routing edges");

                        function getNodeIndex(nodeId) {
                            return nodes.findIndex(node => node.id === nodeId);
                        }

                        // What I want to do is change the angle based on the number of edges between the same nodes
                        // Function to calculate curvature based on number of edges and index
                        function calculateCurvature(edges, fromNode, toNode, edgeid) {
                            const sourceIndex = getNodeIndex(fromNode);
                            const targetIndex = getNodeIndex(toNode);

                            // Get all edges between the two nodes, regardless of direction
                            const allEdges = edges.filter(edge => {
                                return (edge.source.id == fromNode && edge.target.id == toNode) ||
                                    (edge.source.id == toNode && edge.target.id == fromNode);
                            });

                            const edgeCount = allEdges.length;
                            let index = allEdges.findIndex(edge => edge.id == edgeid);

                                // Calculate curvature
                            let curvature = 0;
                            if (edgeCount > 1) {
                                curvature = (index % 2 === 0 ? 1 : -1) * (Math.floor(index / 2) + 1) * 0.1 * edgeCount;
                            }
                            return curvature;
                        }


                        link.attr("d", function (d, i) {


                            // UGH THIS SORT OF WORKS BUT ONLY SOMETIMES CURVES IN THE WRONG DIRECTION

                            var route = colaLayout.routeEdge(d);


                            // If there are only two points in the route, get the midpoint of the route and add it to the route
                            if (route.length === 2) {
                                const midpoint = {
                                    x: (route[0].x + route[1].x) / 2,
                                    y: (route[0].y + route[1].y) / 2
                                };
                                route.splice(1, 0, midpoint);
                            }

                            // Calculate the curvature for the current edge
                            var curvature = calculateCurvature(edges, d.source.id, d.target.id, d.id);

                            // Determine the direction of the edge
                            var dx = route[1].x - route[0].x;
                            var dy = route[1].y - route[0].y;
                            var angle = Math.atan2(dy, dx);
                            var distance = Math.sqrt(dx * dx + dy * dy);
                            /*
                            Angle 0: The edge is horizontal and points to the right.
                            Angle π/2 (90 degrees): The edge is vertical and points upwards.
                            Angle π (180 degrees): The edge is horizontal and points to the left.
                            Angle -π/2 (-90 degrees): The edge is vertical and points downwards.
                            */

                            //Apply curvature to the control points (but this does not help with the direction)
                            route.forEach(function (point, index) {


                                if (index > 0 && index < route.length - 1 && curvature !== 0) {
                                    console.log(d.source.id + " to " + d.target.id);


                                    // Adjust the control points based on the direction
                                    // var offsetX = curvature * Math.cos(angle + Math.PI / 2);
                                    // var offsetY = curvature * Math.sin(angle + Math.PI / 2);
                                    var offsetX = curvature * Math.abs(Math.sin(angle)) * distance;
                                    var offsetY = curvature * Math.abs(Math.cos(angle)) * distance;

                                    console.log("offset: " + offsetX + ", " + offsetY, " angle: ", angle, "curvature: " + curvature);
                                    point.x += offsetX;
                                    point.y += offsetY;
                                }
                            });



                            return lineFunction(route);


                        });

                        // Update label positions after routing edges
                        linkGroups.select("text.linklabel")
                            .attr("x", function (d) {
                                const pathElement = document.querySelector(`path[data-link-id="${d.id}"]`);
                                const pathLength = pathElement.getTotalLength();
                                const midpoint = pathElement.getPointAtLength(pathLength / 2);
                                return midpoint.x;
                            })
                            .attr("y", function (d) {
                                const pathElement = document.querySelector(`path[data-link-id="${d.id}"]`);
                                const pathLength = pathElement.getTotalLength();
                                const midpoint = pathElement.getPointAtLength(pathLength / 2);
                                return midpoint.y;
                            })
                            .attr("text-anchor", "middle")
                            .raise();
                    };

                    const linkGroups = svg.selectAll(".link-group")
                        .data(edges)
                        .enter()
                        .append("g")
                        .attr("class", "link-group");

                    const link = linkGroups.append("path")
                        .attr("class", "link")
                        .attr("data-link-id", d => d.id);

                    linkGroups.append("text")
                        .attr("class", "linklabel")
                        .text(d => d.relName);


                    function isHiddenNode(node) {
                        return node.name.startsWith("_");
                    }


                    var node = svg.selectAll(".node")
                        .data(nodes)
                        .enter().append("rect") // Changed from circle to rect
                        .attr("class", "node")
                        .attr("width", function (d) { 
                            return d.width;   
                        }) // Use node's width
                        .attr("height", function (d) { return d.height; }) // Use node's height
                        .attr("x", function (d) { return -d.width / 2; }) // Center the rectangle on the node's x
                        .attr("y", function (d) { return -d.height / 2; }) // Center the rectangle on the node's y
                        .attr("stroke", function (d) { return d.color; }) // Outline color of the node
                        .attr("stroke-width", 1.5) // Adjust the stroke width as needed
                        .attr("fill", function (d) {
                            let f = isHiddenNode(d) ? "transparent" : "white";
                            return f;
                        }) 
                        .call(colaLayout.drag);

                    var label = svg.selectAll(".label")
                        .data(nodes)
                        .enter().append("text")
                        .attr("class", "label")
                        .each(function (d) {

                            if (isHiddenNode(d)) {
                                return;
                            }

                            // Append tspan for d.name
                            d3.select(this).append("tspan")
                                .attr("x", 0) // Align with the parent text element
                                .attr("dy", "0em") // Start at the same vertical position
                                .style("font-weight", "bold")
                                .text(d.name);

                            var y = 1; // Start from the next line for attributes

                            // Append tspans for each attribute
                            for (let key in d.attributes) {
                                d3.select(this).append("tspan")
                                    .attr("x", 0) // Align with the parent text element
                                    .attr("dy", `${y}em`) // Move each attribute to a new line
                                    .text(key + ": " + d.attributes[key]);
                                y += 1; // Increment for the next line
                            }
                        })
                        .call(colaLayout.drag);


                    // Helper function to calculate new position along the path
                    function calculateNewPosition(previousPosition, pathElement, axis) {
                        const pathLength = pathElement.getTotalLength();
                        const midpointLength = pathLength / 2;
                        const offset = getRandomOffsetAlongPath();

                        let targetLength = midpointLength + offset;

                        if (targetLength >= pathLength) {
                            targetLength = midpointLength;
                        }

                        const point = pathElement.getPointAtLength(targetLength);
                        return axis === 'x' ? point.x : point.y;
                    }

                    node.append("title")
                        .text(function (d) { return d.name; });


                    // Add a rectangle for each group and a label at the top of the group

                    var group = svg.selectAll(".group")
                        .data(groups)
                        .enter().append("rect")
                        .attr("class", "group")
                        .attr("rx", 8).attr("ry", 8)
                        .style("fill", function (d, i) { 
                            var targetNode = nodes[d.keyNode];
                            return targetNode.color;
                        })
                        .attr("fill-opacity", 0.3)
                        .call(colaLayout.drag);

                    var groupLabel = svg.selectAll(".groupLabel")
                        .data(groups)
                        .enter().append("text")
                        .attr("class", "groupLabel")
                        .text(function (d) { return d.name; })
                        .call(colaLayout.drag);


                    colaLayout.on("tick", function () {

                            group.attr("x", function (d) {
                                return d.bounds.x; 
                            })
                            .attr("y", function (d) {
                                return d.bounds.y; 
                            })

                            .attr("width", function (d) { return d.bounds.width(); })
                            .attr("height", function (d) { return d.bounds.height(); })
                            .lower();


                        node
                            .each(function (d) { d.innerBounds = d.bounds.inflate(-1); })
                            .attr("x", function (d) { return d.bounds.x; })
                            .attr("y", function (d) { return d.bounds.y; })
                            .attr("width", function (d) { return d.bounds.width(); })
                            .attr("height", function (d) { return d.bounds.height(); });

                        label
                            .attr("x", d => d.x)
                            .attr("y", d => d.y)
                            .each(function (d) {
                                var y = 0; // Initialize y offset for tspans
                                d3.select(this).selectAll("tspan")
                                    .attr("x", d.x) // Align tspans with the node's x position
                                    .attr("dy", function () {
                                        y += 1; // Increment y for each tspan to create line spacing
                                        return y === 1 ? "0em" : "1em"; // Keep the first tspan in place, move others down
                                    });
                            })
                            .raise();


                        linkGroups.select("path.link")
                            .attr("d", function (d) {
                                var route = cola.makeEdgeBetween(d.source.innerBounds, d.target.innerBounds, 5);
                                return lineFunction([route.sourceIntersection, route.arrowStart]);
                            });

                        linkGroups.select("text.linklabel")
                            .attr("x", d => {
                                const pathElement = document.querySelector(`path[data-link-id="${d.id}"]`);
                                return calculateNewPosition(d.x, pathElement, 'x');
                            })
                            .attr("y", d => {
                                const pathElement = document.querySelector(`path[data-link-id="${d.id}"]`);
                                return calculateNewPosition(d.y, pathElement, 'y');
                            })
                            .raise();





                        groupLabel.attr("x", function (d) { 
                            return d.bounds.x + d.bounds.width() / 2; 
                        
                        }) // Center horizontally
                            .attr("y", function (d) { return d.bounds.y + 12; })
                            .attr("text-anchor", "middle") // Center the text on its position
                            .raise();

                    });

                    colaLayout.start(
                        initialUnconstrainedIterations,
                        initialUserConstraintIterations,
                        initialAllConstraintsIterations,
                        gridSnapIterations)
                        .on("end", routeEdges);

                });
            </script>

        </div>


    </div>


</body>

</html>